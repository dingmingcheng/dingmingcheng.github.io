<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dmc</title>
    <description>欢迎来到我的博客</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 23 Dec 2017 22:16:46 +0800</pubDate>
    <lastBuildDate>Sat, 23 Dec 2017 22:16:46 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>[转]java基础-内存泄漏与内存溢出</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;主要根据之前看的资料进行了一些修改。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wisgood/article/details/16818243&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分内存不可用的情况，重启计算机可以解决，但也有可能再次发生内存泄露，内存泄露和硬件没有关系，它是由软件设计缺陷引起的。&lt;/li&gt;
  &lt;li&gt;内存泄漏可以分为4类：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1) 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。&lt;/p&gt;

&lt;p&gt;2) 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。&lt;/p&gt;

&lt;p&gt;3) 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。&lt;/p&gt;

&lt;p&gt;4) 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存溢出类型：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1) java.lang.OutOfMemoryError: PermGen space&lt;/p&gt;

&lt;p&gt;PermGen space 的全称是 Permanent Generation space, 是指内存的永久保存区域。这块内存主要是被JVM存放Class和Meta信息的，Class在被Loader时就会被放到PermGenspace中，它和存放类实例(Instance)的Heap区域不同，GC不会在主程序运行期对PermGen space进行清理。&lt;/p&gt;

&lt;p&gt;JVM由XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；&lt;/p&gt;

&lt;p&gt;JVM由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。&lt;/p&gt;

&lt;p&gt;该错误常见场合：&lt;/p&gt;

&lt;p&gt;a) 应用中有很多Class，web服务器对JSP进行precompile时。&lt;/p&gt;

&lt;p&gt;b) Webapp下用了大量的第三方jar,其大小超过了JVM默认的大小(4M)时。&lt;/p&gt;

&lt;p&gt;2) java.lang.OutOfMemoryError:Java heap space&lt;/p&gt;

&lt;p&gt;在JVM中如果98%的时间是用于GC且可用的Heap size 不足2%的时候将抛出此异常信息。&lt;/p&gt;

&lt;p&gt;JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；&lt;/p&gt;

&lt;p&gt;JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。&lt;/p&gt;

&lt;p&gt;JVM内存的最大值跟操作系统有很大的关系。32位处理器虽然可控内存空间有4GB，但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统下为2G-3G），而64bit以上的处理器就不会有限制了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注意：如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;该错误常见场合：&lt;/p&gt;

&lt;p&gt;a) Web上传文件时。&lt;/p&gt;

&lt;p&gt;b) 开启大型文件或从数据库中一次取了太多的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Q: Java中会存在内存泄漏吗&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A:  Java中也存在内存泄露。当被分配的对象可达但已无用（未对作废数据内存单元的引用置null）即会引起。&lt;/p&gt;

&lt;p&gt;​         如：&lt;/p&gt;

&lt;p&gt;Java代码&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//此时，所有的Object对象都没有被释放，因为变量v引用这些对象。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//对象加入到Vector后，还必须从Vector中删除，最简单释放方法就是将Vector对象设置为null。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2. Q: 内存泄露、溢出的异同？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A: 同：都会导致应用程序运行出现问题，性能下降或挂起。&lt;/p&gt;

&lt;p&gt;​         异：&lt;/p&gt;

&lt;p&gt;​         1) 内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。&lt;/p&gt;

&lt;p&gt;​         2) 内存泄露可以通过完善代码来避免；内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 如何检测内存泄露？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A: 可以通过一些性能监测分析工具，如 JProfiler、Optimizeit Profiler。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Q: 如何避免内存泄露、溢出？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A:      1) 尽早释放无用对象的引用。&lt;/p&gt;

&lt;p&gt;​          好的办法是使用临时变量的时候，让引用变量在退出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄露。&lt;/p&gt;

&lt;p&gt;​          2) 程序进行字符串处理时，尽量避免使用String，而应使用StringBuffer。&lt;/p&gt;

&lt;p&gt;​          因为每一个String对象都会独立占用内存一块区域，如：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;aaa&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bbb&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//假如执行此次之后str , str2再不被调用，那么它们就会在内存中等待GC回收;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//假如程序中存在过多的类似情况就会出现内存错误；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;​          3) 尽量少用静态变量。&lt;/p&gt;

&lt;p&gt;​         因为静态变量是全局的，GC不会回收。&lt;/p&gt;

&lt;p&gt;​         4) 避免集中创建对象尤其是大对象，如果可以的话尽量使用流操作。&lt;/p&gt;

&lt;p&gt;​         JVM会突然需要大量内存，这时会触发GC优化系统内存环境； 一个案例如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 使用jspsmartUpload作文件上传，运行过程中经常出现java.outofMemoryError的错误，&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 检查之后发现问题：组件里的代码 &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_totalBytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getContentLength&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_binArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newbyte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_totalBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// totalBytes这个变量得到的数极大，导致该数组分配了很多内存空间，而且该数组不能及时释放。 &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 解决办法只能换一种更合适的办法，至少是不会引发outofMemoryError的方式解决。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 参考：http://bbs.xml.org.cn/blog/more.asp?name=hongrui&amp;amp;id=3747&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;​        5) 尽量运用对象池技术以提高系统性能。&lt;/p&gt;

&lt;p&gt;​         生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。&lt;/p&gt;

&lt;p&gt;​         6) 不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。&lt;/p&gt;

&lt;p&gt;​         可以适当的使用hashtable，vector 创建一组对象容器，然后从容器中去取那些对象，而不用每次new之后又丢弃。&lt;/p&gt;

&lt;p&gt;​         7) 优化配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Q: 内存溢出的解决方案？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A: 一是从代码层面进行优化完善，尽量避免该情况发生；&lt;/p&gt;

&lt;p&gt;​         二是调整优化服务器配置：&lt;/p&gt;

&lt;p&gt;​         1) 设置-Xms、-Xmx相等；&lt;/p&gt;

&lt;p&gt;​         2) 设置NewSize、MaxNewSize相等；&lt;/p&gt;

&lt;p&gt;​         3) 设置Heap size, PermGen space:&lt;/p&gt;

&lt;p&gt;​            Tomcat 的配置示例：修改%TOMCAT_HOME%/bin/catalina.bat or catalina.sh&lt;/p&gt;

&lt;p&gt;​             在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_OPTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;-Xms800m -Xmx800m -XX:PermSize&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;128M -XX:MaxNewSize&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;256m -XX:MaxPermSize&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;256m  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;内存泄露与溢出区别，何时产生内存泄露？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;内存溢出是由于jvm虚拟内存不够！ 
而泄漏则是另种概念！!
下面实在摘抄的内容！！ 
下面，我们就可以描述什么是内存泄漏。在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。
在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。
通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。
因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。 
对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义，该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎样解决内存溢出&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、内存溢出类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1、java.lang.OutOfMemoryError:PermGen space&lt;/p&gt;

&lt;p&gt;　　JVM管理两种类型的内存，堆和非堆。堆是给开发人员用的上面说的就是，是在JVM启动时创建;非堆是留给JVM自己用的，用来存放类的信息的。它和堆不同，运行期内GC不会释放空间。如果web app用了大量的第三方&lt;a href=&quot;http://www.chinabyte.com/keyword/JAR/&quot;&gt;jar&lt;/a&gt;或者应用有太多的class文件而恰好MaxPermSize设置较小，超出了也会导致这块内存的占用过多造成溢出，或者tomcat热部署时侯不会清理前面加载的环境，只会将context更改为新部署的，非堆存的内容就会越来越多。&lt;/p&gt;

&lt;p&gt;　　PermGen space的全称是PermanentGeneration space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(GarbageCollection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGenspace错误，这种错误常见在&lt;a href=&quot;http://www.chinabyte.com/keyword/web%E6%9C%8D%E5%8A%A1%E5%99%A8/&quot;&gt;web服务器&lt;/a&gt;对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。&lt;/p&gt;

&lt;p&gt;　　一个最佳的配置例子：(经过本人验证，自从用此配置之后，再未出现过tomcat死掉的情况)&lt;/p&gt;

&lt;p&gt;　　set JAVA_OPTS=-Xms800m -Xmx800m -XX:PermSize=128M-XX:MaxNewSize=256m -XX:MaxPermSize=256m&lt;/p&gt;

&lt;p&gt;　　2、java.lang.OutOfMemoryError:Javaheap space&lt;/p&gt;

&lt;p&gt;　　第一种情况是个补充，主要存在问题就是出现在这个情况中。其默认空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。如果内存剩余不到40%，JVM就会增大堆到Xmx设置的值，内存剩余超过70%，JVM就会减小堆到Xms设置的值。所以&lt;a href=&quot;http://server.chinabyte.com/&quot;&gt;服务器&lt;/a&gt;的Xmx和Xms设置一般应该设置相同避免每次GC后都要调整虚拟机堆的大小。假设物理内存无限大，那么JVM内存的最大值跟&lt;a href=&quot;http://soft.chinabyte.com/os/&quot;&gt;操作系统&lt;/a&gt;有关，一般32位机是1.5g到&lt;a href=&quot;http://www.chinabyte.com/keyword/3G/&quot;&gt;3g&lt;/a&gt;之间，而64位的就不会有限制了。&lt;/p&gt;

&lt;p&gt;　　注意：如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。&lt;/p&gt;

&lt;p&gt;　　垃圾回收GC的角色&lt;/p&gt;

&lt;p&gt;　　JVM调用GC的频度还是很高的，主要两种情况下进行垃圾回收：&lt;/p&gt;

&lt;p&gt;　　当应用程序线程空闲;另一个是java内存堆不足时，会不断调用GC，若连续回收都解决不了内存堆不足的问题时，就会报out of memory错误。因为这个异常根据系统运行环境决定，所以无法预期它何时出现。&lt;/p&gt;

&lt;p&gt;　　根据GC的机制，程序的运行会引起系统运行环境的变化，增加GC的触发机会。&lt;/p&gt;

&lt;p&gt;　　为了避免这些问题，程序的设计和编写就应避免垃圾对象的内存占用和GC的开销。显示调用System.GC()只能建议JVM需要在内存中对垃圾对象进行回收，但不是必须马上回收，&lt;/p&gt;

&lt;p&gt;　　一个是并不能解决内存资源耗空的局面，另外也会增加GC的消耗。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、JVM内存区域组成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　简单的说java中的堆和栈&lt;/p&gt;

&lt;p&gt;　　java把内存分两种：一种是栈内存，另一种是堆内存&lt;/p&gt;

&lt;p&gt;　　1。在函数中定义的基本类型变量和对象的引用变量都在函数的栈内存中分配;&lt;/p&gt;

&lt;p&gt;　　2。堆内存用来存放由new创建的对象和数组&lt;/p&gt;

&lt;p&gt;　　在函数(代码块)中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量所分配的内存空间;在堆中分配的内存由java虚拟机的自动垃圾回收器来管理&lt;/p&gt;

&lt;p&gt;　　堆的优势是可以动态分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的。缺点就是要在运行时动态分配内存，存取速度较慢;&lt;/p&gt;

&lt;p&gt;　　栈的优势是存取速度比堆要快，缺点是存在栈中的数据大小与生存期必须是确定的无灵活性。&lt;/p&gt;

&lt;p&gt;　　java堆分为三个区：New、Old和Permanent&lt;/p&gt;

&lt;p&gt;　　GC有两个线程：&lt;/p&gt;

&lt;p&gt;　　新创建的对象被分配到New区，当该区被填满时会被GC辅助线程移到Old区，当Old区也填满了会触发GC主线程遍历堆内存里的所有对象。Old区的大小等于Xmx减去-Xmn&lt;/p&gt;

&lt;p&gt;　　java栈存放&lt;/p&gt;

&lt;p&gt;　　栈调整：参数有+UseDefaultStackSize -Xss256K，表示每个线程可申请256k的栈空间&lt;/p&gt;

&lt;p&gt;　　每个线程都有他自己的Stack&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、JVM如何设置虚拟内存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　提示：在JVM中如果98%的时间是用于GC且可用的Heap size 不足2%的时候将抛出此异常信息。&lt;/p&gt;

&lt;p&gt;　　提示：Heap Size 最大不要超过可用物理内存的80%，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。&lt;/p&gt;

&lt;p&gt;　　提示：JVM初始分配的内存由-Xms指定，默认是物理内存的1/64;JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。&lt;/p&gt;

&lt;p&gt;　　默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制;空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。&lt;/p&gt;

&lt;p&gt;　　提示：假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。&lt;/p&gt;

&lt;p&gt;　　简单的说就32位&lt;a href=&quot;http://www.chinabyte.com/keyword/%E5%A4%84%E7%90%86%E5%99%A8/&quot;&gt;处理器&lt;/a&gt;虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，&lt;/p&gt;

&lt;p&gt;　　这个限制一般是2GB-3GB(一般来说Windows系统下为1.5G-2G，&lt;a href=&quot;http://www.chinabyte.com/keyword/Linux/&quot;&gt;Linux&lt;/a&gt;系统下为2G-3G)，而64bit以上的处理器就不会有限制了&lt;/p&gt;

&lt;p&gt;　　提示：注意：如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。&lt;/p&gt;

&lt;p&gt;　　提示：设置NewSize、MaxNewSize相等，”new”的大小最好不要大于”old”的一半，原因是old区如果不够大会频繁的触发”主” GC ，大大降低了性能&lt;/p&gt;

&lt;p&gt;　　JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64;&lt;/p&gt;

&lt;p&gt;　　由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。&lt;/p&gt;

&lt;p&gt;　　解决方法：手动设置Heap size&lt;/p&gt;

&lt;p&gt;　　修改TOMCAT_HOME/bin/catalina.bat&lt;/p&gt;

&lt;p&gt;　　在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：&lt;/p&gt;

&lt;p&gt;　　JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:MaxNewSize=256m”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、性能检查工具使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　定位内存泄漏：&lt;/p&gt;

&lt;p&gt;　　JProfiler工具主要用于检查和跟踪系统(限于Java开发的)的性能。JProfiler可以通过时时的监控系统的内存使用情况，随时监视垃圾回收，线程运行状况等手段，从而很好的监视JVM运行情况及其性能。&lt;/p&gt;

&lt;p&gt;　　1.&lt;a href=&quot;http://www.chinabyte.com/keyword/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1/&quot;&gt; 应用服务&lt;/a&gt;器内存长期不合理占用，内存经常处于高位占用，很难回收到低位;&lt;/p&gt;

&lt;p&gt;　　2. 应用服务器极为不稳定，几乎每两天重新启动一次，有时甚至每天重新启动一次;&lt;/p&gt;

&lt;p&gt;　　3. 应用服务器经常做Full GC(GarbageCollection)，而且时间很长，大约需要30-40秒，应用服务器在做Full GC的时候是不响应客户的交易请求的，非常影响系统性能。&lt;/p&gt;

&lt;p&gt;　　因为开发环境和产品环境会有不同，导致该问题发生有时会在产品环境中发生，通常可以使用工具跟踪系统的内存使用情况，在有些个别情况下或许某个时刻确实是使用了大量内存导致out of memory，这时应继续跟踪看接下来是否会有下降，&lt;/p&gt;

&lt;p&gt;　　如果一直居高不下这肯定就因为程序的原因导致内存泄漏。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、不健壮代码的特征及解决办法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1、尽早释放无用对象的引用。好的办法是使用临时变量的时候，让引用变量在退出活动域后，自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄露。&lt;/p&gt;

&lt;p&gt;　　对于仍然有指针指向的实例，jvm就不会回收该资源,因为垃圾回收会将值为null的对象作为垃圾，提高GC回收机制效率;&lt;/p&gt;

&lt;p&gt;　　2、我们的程序里不可避免大量使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域;&lt;/p&gt;

&lt;p&gt;　　3、尽量少用静态变量，因为静态变量是全局的，GC不会回收的;&lt;/p&gt;

&lt;p&gt;　　4、避免集中创建对象尤其是大对象，JVM会突然需要大量内存，这时必然会触发GC优化系统内存环境;显示的声明数组空间，而且申请数量还极大。&lt;/p&gt;

&lt;p&gt;　　5、尽量运用对象池技术以提高系统性能;生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。&lt;/p&gt;

&lt;p&gt;　　6、不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。可以适当的使用hashtable，vector 创建一组对象容器，然后从容器中去取那些对象，而不用每次new之后又丢弃&lt;/p&gt;

&lt;p&gt;　　7、一般都是发生在开启大型文件或跟&lt;a href=&quot;http://com.chinabyte.com/%E6%95%B0%E6%8D%AE%E5%BA%93/&quot;&gt;数据库&lt;/a&gt;一次拿了太多的数据，造成 Out OfMemory Error 的状况，这时就大概要计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/%E8%BD%AC-java%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/%E8%BD%AC-java%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>linux相关命令学习笔记</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;最早应该是在操作系统的课程上接触到了linux系统，那时候其实对linux并没有什么具体的概念，真正接触应该大三下学期，给自己的电脑装了双系统，也在ubuntu上开发过一个web项目，再到暑假去看了《linux权威指南》，也算是入了门了，不过其中的命令也是非常多，常常会忘记，之前会吧平时用到的一些命令存在txt中，既然现在开了博客，也打算一起整理过来。&lt;/p&gt;

&lt;h2 id=&quot;命令&quot;&gt;命令&lt;/h2&gt;

&lt;p&gt;###系统工作命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo($HOSTNAME,$SHELL,asdas,...)
data(&quot;+...&quot;)
reboot
wget
elinks [url] ###系统状态检测命令

ifconfig
uname [-a]
uptime(查看负载情况 或者使用watch -n 1 uptime)
top
free [-m/-g/-k]
who
last
history
uname -a(查看内核/操作系统/CPU信息)
cat /proc/cpuinfo(查看CPU信息) ###工作目录切换命令

pwd [-L/-P]
cd	
ls [-a/-l/-h/-t/...] ###文件文本编辑命令

cat [options] [file](short纯文本文档)
more [options] [file](long纯文本文档)
head [options] [file](	纯文本文档)
tail(纯文本文档)(工作时查看日志常常会用到-f)
od [options][file](特殊格式，进制)
tr [正则] [正则] 文本替换
wc [-lwc] (统计作用)
diff [optinons] [file] [file] ###文件目录管理命令

drwxrwxrwx(是否为目录，属主，属组，其他用户)
touch
mkdir [options]
cp [options] 源文件 目标文件
mv [options] 源文件 [目标路径|目标文件名]
rm [options(r文件夹,f)] rmdir
dd [options] 指定大小的拷贝的文件或指定转换文件
chmod u+(增加权限,u(用户)，+(增加权限),r,w,x) ###用户与组管理命令

useradd [options] username
passwd
userdel 删除用户表格
groupadd创建群组
users ###打包压缩文件命令

tar [options] [file] {c压缩,x解压,z Gzip,v显示过程,f目标文件名，C指定路径} ###文件查询搜索命令

grep [options] [file](grep -R &quot;&quot; .  查找文件中的内容)
awk
find [查找路径] 寻找条件 操作(find . -name &quot;&quot;  查找文件名) 管道命令符 将前一个命令的标准输出当作后一个命令的标准输入
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###输入输出重定向&lt;/p&gt;

&lt;p&gt;stdin 0
stdout 1
stderr 2&lt;/p&gt;

&lt;p&gt;输出重定向&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;命令 &amp;gt; 文件 ，标准输出重定向到文件中（clear）
命令 2&amp;gt; 文件 ，错误输出重定向到文件中（clear）
命令 &amp;gt;&amp;gt; 文件，附加
命令 2&amp;gt;&amp;gt; 文件，附加
命令 &amp;gt;&amp;gt; 文件 2&amp;gt;&amp;amp;1 共同写入，附加 ,或者&amp;amp;&amp;gt;&amp;gt; 输入重定向
命令 &amp;lt; 文件 文件作为命令的输入（clear）
命令 &amp;lt;&amp;lt; 文件 追加	
命令 &amp;lt;&amp;lt; 分界符 追加，遇到分界符停止
命令 &amp;lt; 文件1 &amp;gt; 文件2 将文件1作为输入并输出到文件2 命令行通配符
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###实用的PATH变量&lt;/p&gt;

&lt;p&gt;1.如果以绝对/相对路径输入的命令则直接执行
2.检查是否为alias别名命名
3.bash判断其是否为“内部命令”还是“外部命令”
4.通过$PATH中的路径进行命令查找&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;env
$HOME
export,提升为全局变量
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;其他命令&quot;&gt;其他命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;read -p [提示语句] 变量名
at [date]
at [-l/c] atrm 序号
crontab [-u 用户] file/[-l/e/r]
ps -aux 和 top
pidof
kill -9 [PID]
man
type
which ###网络

route add -net [目的子网] gw [网关地址] netmask [子网掩码] metric [路由跳数] 
nmtui
nmcli
ssh 连接远程主机-keygen
scp文件传送
lsof
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 22 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/linux%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/linux%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>[转]jvm工作原理和流程</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;暑假期间看了一段时间的《深入JVM虚拟机》，再加上网上一些归纳比较好的知识，对jvm也是可以说上几句，这篇博文更多的是整理其他博主的博文,也感谢互联网让我站在了巨人的肩膀上。&lt;/p&gt;

&lt;p&gt;先放上参考链接吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/CSDN_980979768/article/details/47281037?locationNum=7&amp;amp;fps=1&quot;&gt;Java 详解 JVM 工作原理和流程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;内容&quot;&gt;内容&lt;/h2&gt;

&lt;p&gt;作为一名Java使用者，掌握JVM的体系结构也是必须的。
说起Java，人们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。&lt;/p&gt;

&lt;p&gt;Java平台由Java虚拟机和Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。&lt;/p&gt;

&lt;p&gt;JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。下面我们从JVM的体系结构和它的运行过程这两个方面来对它进行比较深入的研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、Java虚拟机的体系结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;·每个JVM都有两种机制：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;①类装载子系统：装载具有适合名称的类或接口&lt;/p&gt;

&lt;p&gt;②执行引擎：负责执行包含在已装载的类或接口中的指令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;·每个JVM都包含&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于JVM的学习，在我看来这么几个部分最重要：&lt;/p&gt;

&lt;p&gt;Java代码编译和执行的整个过程&lt;/p&gt;

&lt;p&gt;JVM内存管理及垃圾回收机制&lt;/p&gt;

&lt;p&gt;下面分别对这几部分进行说明：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Java代码编译和执行的整个过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也正如前面所说，Java代码的编译和执行的整个过程大概是：开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。&lt;/p&gt;

&lt;p&gt;（1）Java代码编译是由Java源码编译器来完成，也就是Java代码到JVM字节码（.class文件）的过程。 流程图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic4.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（2）Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java代码编译和执行的整个过程包含了以下三个重要的机制:&lt;/p&gt;

&lt;p&gt;·Java源码编译机制&lt;/p&gt;

&lt;p&gt;·类加载机制&lt;/p&gt;

&lt;p&gt;·类执行机制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）Java源码编译机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java 源码编译由以下三个过程组成：&lt;/p&gt;

&lt;p&gt;①分析和输入到符号表&lt;/p&gt;

&lt;p&gt;②注解处理&lt;/p&gt;

&lt;p&gt;③语义分析和生成class文件&lt;/p&gt;

&lt;p&gt;流程图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后生成的class文件由以下部分组成：&lt;/p&gt;

&lt;p&gt;①结构信息：包括class文件格式版本号及各部分的数量与大小的信息&lt;/p&gt;

&lt;p&gt;②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池&lt;/p&gt;

&lt;p&gt;③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）类加载机制&lt;/strong&gt;
JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;①Bootstrap ClassLoader&lt;/p&gt;

&lt;p&gt;负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类&lt;/p&gt;

&lt;p&gt;②Extension ClassLoader&lt;/p&gt;

&lt;p&gt;负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包&lt;/p&gt;

&lt;p&gt;③App ClassLoader&lt;/p&gt;

&lt;p&gt;负责记载classpath中指定的jar包及目录中class&lt;/p&gt;

&lt;p&gt;④Custom ClassLoader&lt;/p&gt;

&lt;p&gt;属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader&lt;/p&gt;

&lt;p&gt;加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）类执行机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。&lt;/p&gt;

&lt;p&gt;JVM执行class字节码，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、JVM内存管理及垃圾回收机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用），结构图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）堆内存（heap）&lt;/p&gt;

&lt;p&gt;所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。 
操作系统有一个记录空闲内存地址的&lt;strong&gt;链表&lt;/strong&gt;，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。但由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。这时由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不是在堆，也不是在栈，而是直接在进程的地址空间中保留一块内存，虽然这种方法用起来最不方便，但是速度快，也是最灵活的。堆内存是向高地址扩展的数据结构，是不连续的内存区域。由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，&lt;strong&gt;堆获得的空间比较灵活，也比较大&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;（2）栈内存（stack）&lt;/p&gt;

&lt;p&gt;在Windows下, 栈是向低地址扩展的数据结构，是一块&lt;strong&gt;连续的内存区域&lt;/strong&gt;。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，&lt;strong&gt;能从栈获得的空间较小&lt;/strong&gt;。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 由系统自动分配，速度较快。但程序员是无法控制的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;堆内存与栈内存需要说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基础数据类型直接在栈空间分配，方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量 。方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。局部变量new出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。方法调用时传入的literal参数，先在栈空间分配，在方法调用完成后从栈空间收回。字符串常量、static在DATA区域分配，this在堆空间分配。数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（3）本地方法栈（java中的jni调用）&lt;/p&gt;

&lt;p&gt;用于支持native方法的执行，存储了每个native方法调用的状态。对于本地方法接口，实现JVM并不要求一定要有它的支持，甚至可以完全没有。Sun公司实现Java本地接口(JNI)是出于可移植性的考虑，当然我们也可以设计出其它的本地接口来代替Sun公司的JNI。但是这些设计与实现是比较复杂的事情，需要确保垃圾回收器不会将那些正在被本地方法调用的对象释放掉。&lt;/p&gt;

&lt;p&gt;（4）方法区（method）&lt;/p&gt;

&lt;p&gt;它保存方法代码(编译后的java代码)和符号表。存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代（Permanet Generation）来存放方法区，可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。（补充：java8中已经移除永久代（permGen），使用元空间（metaspace），元空间位于本地内存（哈哈），主要是考虑到永久代大小比较难估计，降低了内存利用率，例如两个不同的项目都用到了同一个开源包，其class文件之前是存在各自的永久代中，而现在是只有一个，就是在元空间中）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;堆里聚集了所有由应用程序创建的对象，JVM也有对应的指令比如
 new, newarray, anewarray和multianewarray，然并没有向 C++ 的 delete，free 
等释放空间的指令，Java的所有释放都由 GC 来做，GC除了做回收内存之外，另外一个重要的工作就是内存的压缩，这个在其他的语言中也有类似的实现，相比 C++ 
不仅好用，而且增加了安全性，当然她也有弊端，比如性能这个大问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Java虚拟机的运行过程示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面对虚拟机的各个部分进行了比较详细的说明，下面通过一个具体的例子来分析它的运行过程。&lt;/p&gt;

&lt;p&gt;虚拟机通过调用某个指定类的方法main启动，传递给main一个字符串数组参数，使指定的类被装载，同时链接该类所使用的其它的类型，并且初始化它们。例如对于程序：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译后在命令行模式下键入： java HelloApp run virtual machine&lt;/p&gt;

&lt;p&gt;将通过调用HelloApp的方法main来启动java虚拟机，传递给main一个包含三个字符串”run”、”virtual”、”machine”的数组。现在我们略述虚拟机在执行HelloApp时可能采取的步骤。&lt;/p&gt;

&lt;p&gt;开始试图执行类HelloApp的main方法，发现该类并没有被装载，也就是说虚拟机当前不包含该类的二进制代表，于是虚拟机使用ClassLoader试图寻找这样的二进制代表。如果这个进程失败，则抛出一个异常。类被装载后同时在main方法被调用之前，必须对类HelloApp与其它类型进行链接然后初始化。链接包含三个阶段：检验，准备和解析。检验检查被装载的主类的符号和语义，准备则创建类或接口的静态域以及把这些域初始化为标准的默认值，解析负责检查主类对其它类或接口的符号引用，在这一步它是可选的。类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化。整个过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic12.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/%E8%BD%AC-jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/%E8%BD%AC-jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>mybatis自动生成工具</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;实习也一个月多了，也学到了很多的东西，记得刚开始接触开发时，其中感觉最恶心的是mybatis的相关文件的编写，主要是Mapper文件，之前自己的个人项目中，数据库相关的字段命名都是很不规范的，而且字段也少。所以一开始接触企业项目时真的是头痛，mapper基础文件又长。第二天感觉这样效率很低，就自己写了一个java程序，通过在建模工具中导出的sql建表语句进行生成需要的部分。最近不知怎么突然感觉肯定有相应的工具类，果然。。。（记得有个老哥一开始还自己写了getter和setter的自动生成的脚本，哈哈哈），既然有这些比较稳定的工具，肯定比自己几小时写的程序好用的。&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;h3 id=&quot;相关文件下载&quot;&gt;相关文件下载&lt;/h3&gt;

&lt;p&gt;1.&lt;a href=&quot;https://github.com/mybatis/generator/releases&amp;gt;[](https://github.com/mybatis/generator/releases/tag/mybatis-generator-1.3.2)&quot;&gt;Mybatis-Generator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.数据库驱动jar包，我这里使用的是mysql，可以去&lt;a href=&quot;http://mvnrepository.com/artifact/mysql/mysql-connector-java&quot;&gt;这里&lt;/a&gt; 下载，我使用的是5.1.44版本&lt;/p&gt;

&lt;h3 id=&quot;具体操作过程&quot;&gt;具体操作过程&lt;/h3&gt;

&lt;p&gt;1.解压下载的Mybatis-Generator的压缩包，进入lib文件夹下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;放入之前已经下载好的mysql驱动包，以及创建好generatorConfig.xml配置文件，再创建相关的生成的类的文件夹&lt;/p&gt;

&lt;p&gt;2.generatorConfig.xml文件，还是比较好修改的&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;generatorConfiguration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--数据库驱动--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;classPathEntry&lt;/span&gt;    &lt;span class=&quot;na&quot;&gt;location=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mysql-connector-java-5.1.44.jar&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DB2Tables&quot;&lt;/span&gt;    &lt;span class=&quot;na&quot;&gt;targetRuntime=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MyBatis3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;commentGenerator&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;suppressDate&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;suppressAllComments&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/commentGenerator&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--数据库链接地址账号密码--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;jdbcConnection&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driverClass=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;connectionURL=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc:mysql://127.0.0.1:3306/dmc-test?characterEncoding=utf8&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;userId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;root&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;password=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;******&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/jdbcConnection&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;javaTypeResolver&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;forceBigDecimals&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/javaTypeResolver&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--生成Model类存放位置--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;javaModelGenerator&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targetPackage=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test.model&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targetProject=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;enableSubPackages&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;trimStrings&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/javaModelGenerator&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--生成映射文件存放位置--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;sqlMapGenerator&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targetPackage=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test.mapping&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targetProject=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;enableSubPackages&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/sqlMapGenerator&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--生成Dao类存放位置--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;javaClientGenerator&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;XMLMAPPER&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targetPackage=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test.dao&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targetProject=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;enableSubPackages&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/javaClientGenerator&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--生成对应表及类名--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;table&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;tableName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testtable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;domainObjectName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Testtable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enableCountByExample=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enableUpdateByExample=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enableDeleteByExample=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enableSelectByExample=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;selectByExampleQueryId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/generatorConfiguration&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.在lib文件夹下输入以下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -jar mybatis-generator-core-1.3.5.jar -configfile generatorConfig.xml -overwrite
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.完成&lt;/p&gt;

&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;

&lt;p&gt;通过工具的使用，可以大大提高工作的效率，而且文件的准确性也没问题，之后也可以使用起来。&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/mybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/mybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</guid>
        
        <category>mybatis</category>
        
        
      </item>
    
      <item>
        <title>github sshkey添加</title>
        <description>&lt;h2 id=&quot;ssh配置&quot;&gt;SSH配置&lt;/h2&gt;

&lt;p&gt;ssh配置其实很简单，网上也有很多的教程，直接给个传送门吧，一步一步来就OK了，&lt;a href=&quot;https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html&quot;&gt;windows下github ssh配置&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/yin1031468524/article/details/50096723&quot;&gt;linux/mac下配置&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;git协议&quot;&gt;git协议&lt;/h2&gt;

&lt;p&gt;通常使用git时，进行push，pull，clone等操作时，是使用https协议和SSH协议&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#通常将远程仓库拉到本地有以下两种方式&lt;/span&gt;
git clone git@github.com:dingmingcheng/dingmingcheng.github.io.git
git clone https://github.com/dingmingcheng/dingmingcheng.github.io.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而在使用时，https协议可以说是非常不方便的，因为每次都需要输入密码，而git主要是使用SSH协议进行数据加密传输。&lt;/p&gt;

&lt;h3 id=&quot;ssh协议&quot;&gt;ssh协议&lt;/h3&gt;

&lt;p&gt;百度百科上是这么介绍ssh协议的：“SSH 为 &lt;a href=&quot;https://baike.baidu.com/item/Secure%20Shell&quot;&gt;Secure Shell&lt;/a&gt; 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为&lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95&quot;&gt;远程登录&lt;/a&gt;会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括&lt;a href=&quot;https://baike.baidu.com/item/HP-UX&quot;&gt;HP-UX&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Linux&quot;&gt;Linux&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/AIX&quot;&gt;AIX&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Solaris/3517&quot;&gt;Solaris&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Digital&quot;&gt;Digital&lt;/a&gt; &lt;a href=&quot;https://baike.baidu.com/item/UNIX&quot;&gt;UNIX&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Irix&quot;&gt;Irix&lt;/a&gt;，以及其他平台，都可运行SSH”&lt;/p&gt;

&lt;p&gt;简单来说，当我们需要远程登录其他的机器时，ssh就起了很大的作用，使用登陆主要有两种方式，第一种是口令登陆，就是你知道远程机器的密码，每次连接时通过口令登陆即可。（服务端默认端口是22）&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh user@host
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之后输入密码即可。&lt;/p&gt;

&lt;p&gt;还有一种就是通过公钥，首先需要在本机上生成一对密钥，mac/linux下时在当前用户的文件夹下&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/.ssh/
ls
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;里面会有id_rsa和id_rsa.pub，其中id_rsa.pub中的内容就是你生成公钥，也就是要存在远程主机上的秘钥。&lt;/p&gt;

&lt;p&gt;登陆原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机将一个随机字符串发送给客户端，客户端根据自己的私钥加密这个随机字符串之后再发送给远程服务器。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。&lt;/p&gt;

&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;

&lt;p&gt;其实以上只是个人的一些简单的理解，如有错误希望提出，说到加密，其实涉及到了另外一个计算机分支网络安全，计算机发展太快，希望自己能脚踏实地，一点一滴去积累，异步一个脚印。&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/github%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/github%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/</guid>
        
        <category>git</category>
        
        
      </item>
    
      <item>
        <title>个人博客搭建教程</title>
        <description>&lt;p&gt;  先写写我的博客的搭建教程吧，希望能帮到需要的人。&lt;/p&gt;

&lt;h2 id=&quot;总体情况&quot;&gt;总体情况&lt;/h2&gt;

&lt;p&gt;  我的博客搭建环境是在mac，主要是使用了jekyll框架搭建，之前看网上的教程都是使用hexo，自己之前也是用hexo试过，不过过了几天，发现了一个问题，就是平时在家主要是用windows，然后每次修改就比较麻烦，于是就用了&lt;a href=&quot;https://www.jekyll.com.cn/&quot;&gt;jekyll&lt;/a&gt;来搭建，网站部署在github上。使用jekyll的好吃也很明显，就是它是静态的网站，如果想写微博，机器只需要一个git和一个markdown编辑器就可以了,如果说你不，这也是我使用的主要的原因，主题模板也是使用了网上的一个大牛的-&amp;gt;&lt;a href=&quot;http://baixin.io&quot;&gt;大牛的博客&lt;/a&gt;，对，还要说一点，搭建环境最好是在mac或者linux操作系统上，windows实在是太智商捉急了。&lt;/p&gt;

&lt;h2 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h2&gt;

&lt;p&gt;  以下的搭建是在mac环境下进行的&lt;/p&gt;

&lt;h3 id=&quot;ruby&quot;&gt;Ruby&lt;/h3&gt;

&lt;p&gt;首先是ruby的环境安装，mac自带ruby环境，不过自己用时发现版本过低，是要2.1以上，于是重新安装，本来电脑中有homebrew，想用homebrew安装，但不知为何，反正失败了，后面就改用rvm，具体过程如下：&lt;/p&gt;

&lt;h4 id=&quot;rvm安装&quot;&gt;rvm安装&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -L https://get.rvm.io | bash -s stable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;载入rvm环境&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.rvm/scripts/rvm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;版本检查&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rvm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;通过rvm安装ruby&quot;&gt;通过rvm安装ruby&lt;/h4&gt;

&lt;p&gt;查看可以选择的版本&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rvm list known
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会出现下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着开始安装，泡杯咖啡的时间就ok了&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rvm install 2.4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;确认是否安装成功&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby -v
gem -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;jekyll&lt;/h3&gt;

&lt;p&gt;jekyll的环境安装&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;确认jekyll已安装&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bundler&quot;&gt;bundler&lt;/h3&gt;

&lt;p&gt;bundler安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shelll&quot;&gt;gem install bundler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bundler查看&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundler -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###以上用于本地环境的搭建，环境搭建好后就简单了&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll new my-awesome-site
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;my-awesome-site
jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;窗口不能关闭，用浏览器访问localhost:4000就可以了&lt;/p&gt;

&lt;h3 id=&quot;git-环境搭建&quot;&gt;git 环境搭建&lt;/h3&gt;

&lt;p&gt;git主要是用与github，而github主要是因为其中的github page(你写博客总是希望发布到互联网上的吧。。。还可以顺便和非计算机专业的妹子吹个牛，岂不是美滋滋)，githubpage的介绍可以看&lt;a href=&quot;https://pages.github.com/&quot;&gt;这里&lt;/a&gt;，主要是充当了一个服务器，省去了很多的麻烦。&lt;/p&gt;

&lt;p&gt;首先是github账号的注册。。。emmm跳过了&lt;/p&gt;

&lt;p&gt;之后“https://github.com/{你注册时的username}”就是你的github主页了&lt;/p&gt;

&lt;h3 id=&quot;github-page的搭建&quot;&gt;github page的搭建&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图选择Repositories,然后选择New&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想关选项就类似上图吧，开源协议就填GPL协议吧&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拉到下方，选择choose a theme这个按钮，跳转后点击select theme就可以，再访问https://{你的username}.github.io 你发现了什么，okay。&lt;/p&gt;

&lt;p&gt;接着是需要生成一对秘钥，将公钥添加到github上，具体原理就不多说了，这一部分可以看我的另外一篇文章，“github初始化设置”&lt;/p&gt;

&lt;h4 id=&quot;至此github-page的页面也可用了&quot;&gt;至此github page的页面也可用了&lt;/h4&gt;

&lt;p&gt;接着就是将你本地的博客上传到github page上了。首先是选个主题，直接去&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;jekyll主题&lt;/a&gt;可以找到一个不错的主题，直接下载下来，将这些文件上传到github中那个刚刚创建的仓库就可以了。另外说一句，要更改博客相关样式需要在下载下来的文件夹的根目录下的__config.yml文件中修改，里面应该都有注释，不难。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;pic7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;复制其中的内容&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone 上面复制了的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后通过cd命令到该文件夹的更目录下，将之前下载下来的主题替换这之中全部的文件&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add .
git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;update&quot;&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等文件上传成功，这时，在安装ruby时泡的咖啡估计也冷了，可以倒了，杯子洗好再去看看你的主页&lt;/p&gt;

&lt;h2 id=&quot;博文编写&quot;&gt;博文编写&lt;/h2&gt;

&lt;p&gt;接下来就简单了，直接使用markdown编辑器，mac下我用的是Typora，windows下用的是markdownpad，多说一句，markdown还是一个很不错的编辑工具的，可以制作简历，写文档等等，优点可以自行百度。&lt;/p&gt;

&lt;p&gt;直接将写好的文件存入_posts中就可以了。&lt;/p&gt;

&lt;p&gt;当然别忘记了去看看下载下来的主题中自带的_posts中的文章，保证格式正确（主要是开头一些title，layout之类的）&lt;/p&gt;

&lt;p&gt;差不多，总的来说就是这样。&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>出发了，少年</title>
        <description>&lt;p&gt;    这是我的第一篇的博客，趁着今天周六，想写一篇杂记，写点东西，但一时对着电脑，竟不知如何提笔，算了，还是想到什么写什么了。&lt;/p&gt;

&lt;p&gt;   还是先讲讲为何会想到搭建这个博客吧。要说初衷，是因为专业，因为职业，作为计算机行业，不断学习肯定是必须的，想到之前在微博上看见这么一句话，“比你聪明的人比你还努力，为什么还要努力”，虽说是个段子，别的行业我不清楚，前半句来形容我们专业是再恰当不过的了，无论是之前acm在役时，还是之后转服务器，转工程之后，总是会碰见许多的问题，遇到问题也更多是去百度去谷歌，不过自己也没有黄蓉母亲那种过目不忘的本领，还是希望记下这些问题和解决方法，进行一个简单的归纳总结，当然如果能帮到其他同学更是我的荣幸。还有就是想练练文笔，想写点东西，这其实更多得和我的成长有关系，我爸年轻的时候（给我爸吹一波：））很是痴迷文学，常常通宵写文章，也是曾是出版社的记者，当地作协的骨干，然而颇有讽刺意味的是，我的语文成绩一直很差，数学很强，这正与我爸完全相反。进入大学后，也不再需要去学习语文，竟不知为何想写点东西，特别是在acm退役之后（恩。。。终于不害怕偏题了，虽然没有题目）。还有我觉得我是一个比较有归属感，集体感的人，无论是之前大学时候的学生会，集训队，还是现在刚开的博客。&lt;/p&gt;

&lt;h2 id=&quot;秋招&quot;&gt;秋招&lt;/h2&gt;

&lt;p&gt;  说到秋招，也有意思，顺便也写了吧。要说到秋招，正式开始准备应该是七月初，就是邱神和狸神来我学校这边&lt;del&gt;疯狂打dota&lt;/del&gt;游山玩水之后吧。那时候ck和yxh都回家了，一个人在寝室开刷leetcode，之前一年多在集训队还是挺勤得，所以刷起来也还是很快的。之后就开始各种看面经……//TODO&lt;/p&gt;

&lt;p&gt;   我想了想，这流水账记起来一下子真记不完，细节一些东西还是下次再写吧，反正这博客也没人看，这篇文章我想也之后也没什么兄弟会看，还是先打个TODO吧。总的来说秋招很遗憾，主要的问题也还是自己几个月学的东西太多了，缺乏一定的实践去沉淀，还有就是运气不太好，刚来杭州一两天就面瘫了，然后连着一个多星期的面试，真的是什么都撞到一起，那段时间心情也挺复杂的，满怀信心来杭，突然就当头一棒，连个“分布式”的音都发不出来，别说面带笑容了，我一笑都怕面试的师兄揍我（其实面试的师兄都还是很不错的，会引导我，主要是自己平时笑就比较夸张，然后emmm那时候的笑就是“蔑笑”，就是嘴角只扬一边的那种，哈哈哈，画面感好强），然后医生又说什么容易拉下后遗症（兄弟啊，他娘的我老婆都还没娶啊）……不说了，说多了矫情，无论是之前给我内推的认识的和不认识的师兄，还是面试时指引我前进的师兄，亦或是现在实习时一直为我解惑的师兄，都是我生命中非常宝贵的一笔财富（现在还记得初三时，我爸送给我的一句话，“身边的良师益友会是你一生的财富，愈久愈回味无穷”）。&lt;/p&gt;

&lt;h2 id=&quot;烂尾&quot;&gt;烂尾&lt;/h2&gt;

&lt;p&gt;  这一个月实习也渐渐熟悉了很多的东西，学校那边的毕业设计也差不多了，自己的面瘫也快好了，这周在下班的零碎的时间也搭起了这个博客，这几天会把之前秋招以及现在实习学到的写起来，不忘初心，奔跑吧，骄傲的少年（我想了想，之后肯定会写一篇关于摇滚乐的杂记吧，写写那些人那些事，真的很喜欢，有兴趣的也可以加我网易云音乐id是“haochun1”,名字是他妈得蠢啊）。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;人这一生，也就一次，岂敢将就，青春将逝，态度不失，生命不息，折腾不止&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/%E5%87%BA%E5%8F%91%E4%BA%86-%E5%B0%91%E5%B9%B4/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/%E5%87%BA%E5%8F%91%E4%BA%86-%E5%B0%91%E5%B9%B4/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
  </channel>
</rss>
