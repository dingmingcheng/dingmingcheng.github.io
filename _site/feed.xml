<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>潘柏信</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 09 Dec 2017 00:10:44 +0800</pubDate>
    <lastBuildDate>Sat, 09 Dec 2017 00:10:44 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>Wifi 定位原理及 iOS Wifi 列表获取</title>
        <description>&lt;p&gt;　　对于大家来说，Wifi 应该是一个很熟悉的词了，我们每天都可能在使用 Wifi 热点。Wifi 除了能给我们提供热点之外同时还有定位的作用， 现在移动设备的对用户的隐私保护是越来越严格了，就如定位功能，必须要经过设备用户的授权才能使用 Location 给这台设备定位。这些严格的隐私政策对用户起到到保护作用，但对开发人员却是一种阻碍，在产品强需求的情况下用户是会授权的，如地图类应用，但是另外一些没有对定位强需求的产品，用户可能就不会给你授权了，这是我们可以考虑下 Wifi 定位了。&lt;/p&gt;

&lt;h3 id=&quot;wifi-定位原理&quot;&gt;Wifi 定位原理&lt;/h3&gt;

&lt;p&gt;　　当我们使用手机扫面 Wifi 的时候，其实就可以定位到这台手机的位置信息了。每个 Wifi 路由开启后，都会不停的往四周发射信号，我们把 Wifi 路由想象成太阳以某种频度不停的往周围发射电磁波，电磁波会因距离的削弱，同时也会因为物体阻挡而削弱。例子就是我们在离 Wifi 路由器同样远的位置，有些地方信号强度高有些地方信号强度低。路由同时也叫 Wifi 热点（或者 Wifi AP：Access Point）。每一个 Wifi 路由器都会有一个 BSSID，很多人都管这个 BSSID 叫 MAC 地址（其实 BSSID 并不是 MAC 地址），BSSID 设定了一般就不会在变也不会重复，也就意味着是全球唯一的，这是路由制造的规则，既然有规则那么就会有不遵守规则的人，文章结尾会介绍不遵守规则的人是如何害人害己的。&lt;/p&gt;

&lt;p&gt;　　刚才提到的 BSSID，在 Wifi 路由器的发射中是可以检测到的，同时 Wifi 路由信号还伴随着，SSID(路由器的名称：如XX的Wifi)、signalStrength（手机接收到Wifi的信号强度）及其它信息。看到这里你应该知道如何使用Wifi定位的了，条件：唯一不变的BSSID 和 手机到路由器的信号强度。思路：Wifi 信号是有范围的，我们假设这个范围就是10米为半径的一个圆(实际情况根据Wifi路由厂商和路由器周围环境而定)，我们去采集一些Wifi热点回来，某家水果店的 Wifi、某家餐馆的 Wifi 等等，我们自己去采集的我们肯定知道他们的具体位置，及刚才提到的 Wifi 中的信息：BSSID、SSID、signalStrength，再把他们存入数据库，采集的人可以很多：专业采集人员、出租车司机、快递员等等，他们经常穿梭于大街小巷，其实我们每个人都是Wifi数据库的采集人员，我们的手机厂商每天都在默默的采集着我们的位置信息，iPhone手机系统设置里就可以看到你今天去哪了，你的Wifi连接过哪些设备也是知道的。时间越久Wifi数据库信息越丰富，最终会发现每个BSSID会对应多个SSID和signalStrength，因为SSID是可以修改的，signalStrength是由于在这个Wifi热点的周围不同位置采集的，所以信号强度也不同。采集的信号强度越多，给BSSID也就是这个Wifi热点的定位就越精准。&lt;/p&gt;

&lt;p&gt;　　现在如果我去一个陌生的地方，我打开手机扫描周围的 Wifi 刚好扫描到了一个或几个，我把这个 Wifi 信息（BSSID）传给服务器，服务器通过这个 BSSID 去数据库查找，就能直接匹配到对应的位置，返回给我。如果匹配不到则表示这里没人来采集过 Wifi 信息，或者是这个 Wifi 热点是最近布置的，采集人员还没来得及采集。服务器可以把这些未采集到的先分类后期统一规划。&lt;/p&gt;

&lt;p&gt;　　Wifi 定位整体功能是需要服务端来配合的，也就表示必须要有网络环境才行。其实移动端(手机、Pad等)也可以独立完成，不过对技术和设备硬件要求会高很多，全球的 Wifi 热点是一个很庞大的数据量，需要经过高精度的无损压缩后放在内存很大的手机里才行，或许多年以后可以实现吧(即使技术上能实现了，对于产品和研发来说收益、风险、和工作量又是一场PK)&lt;/p&gt;

&lt;h3 id=&quot;ios-申请获取-wifi-列表权限&quot;&gt;iOS 申请获取 Wifi 列表权限&lt;/h3&gt;

&lt;p&gt;　　知道了原理有啥用呢，能实现么？好吧现在就遇到问题了，移动设备如今主要是 Andorid 和 iOS, Android 上可以直接扫描 Wifi 列表获取相关信息，自己去网上找找, 所以说会原理不一定会技术实现，我也就只能讲讲 iOS 的技术实现了。              &lt;br /&gt;
　　iOS 上获取 Wifi 列表其实也有很大限制，在 iOS 9 以前是不能获取Wifi列表的，只能获取当前连接的 Wifi 信息，也就表示只有连接了 Wifi 才能定位，刚才文章说到的场景是，我在一个陌生的原理，拿出手机扫描 Wifi ，也就是我并没连接那里的 Wifi（我不知道密码我怎么连啊）。Apple 在 iOS 9 以后，提供了获取Wifi列表的API，但是获取Wifi列表是有门槛的，主要步骤有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1、向 Apple 申请开发 Network Extension 权限&lt;/li&gt;
    &lt;li&gt;2、申请包含 Network Extension 的描述文件&lt;/li&gt;
    &lt;li&gt;3、配置 Info.plist&lt;/li&gt;
    &lt;li&gt;4、配置 entitlements&lt;/li&gt;
    &lt;li&gt;5、iOS 获取 Wifi 列表代码实现&lt;/li&gt;
    &lt;li&gt;6、获取Wifi列表回调&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1向-apple-申请开发-network-extension-权限&quot;&gt;1、向 Apple 申请开发 Network Extension 权限&lt;/h3&gt;

&lt;p&gt;　　首先要先写封邮件给 &lt;a href=&quot;mailto:networkextension@apple.com&quot;&gt;networkextension@apple.com&lt;/a&gt; ，问苹果要开发 Network Extension 的权限。   &lt;br /&gt;
苹果收到邮件后会自动回复邮件，在 &lt;a href=&quot;https://developer.apple.com/contact/network-extension/&quot;&gt;https://developer.apple.com/contact/network-extension/&lt;/a&gt; 里面填写申请表格，内容包括：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Organization：               

Company / Product URL:             

What's your product's target market?              

What's your company's primary function?             

Describe your application and how it will use the Network Extension framework.            

What type of entitlement are you requesting?                     

。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;申请后大概两周左右能收到 Aplle的 确认信，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi, 

Thanks for your interest in the Network Extension APIs.

We added a new template containing the Network Extension entitlements to your team.

。。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2申请包含-network-extension-的描述文件&quot;&gt;2、申请包含 Network Extension 的描述文件&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/Wifilist/PastedGraphic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择包含 Network Extension 的描述文件，后点击下载，下载完成双击描述文件。&lt;/p&gt;

&lt;h3 id=&quot;3配置-infoplist&quot;&gt;3、配置 Info.plist&lt;/h3&gt;

&lt;p&gt;Xcode Info.plist 里 Required background modes 添加 一个 network-authentication(item)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/Wifilist/infoplist.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4配置-entitlements&quot;&gt;4、配置 entitlements&lt;/h3&gt;

&lt;p&gt;Demo.entitlements（Demo是项目名称） 里添加 Key-Value: com.apple.developer.networking.HotspotHelper -&amp;gt; YES&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/Wifilist/entitlement.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5ios-获取-wifi-列表代码实现&quot;&gt;5、iOS 获取 Wifi 列表代码实现&lt;/h3&gt;

&lt;p&gt;导入头文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;NetworkExtension/NetworkExtension.h&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)getWifiList {

	if (![[[UIDevice currentDevice] systemVersion] floatValue] &amp;gt;= 9.0) {return;}
	dispatch_queue_t queue = dispatch_queue_create(&quot;com.leopardpan.HotspotHelper&quot;, 0);
	[NEHotspotHelper registerWithOptions:nil queue:queue handler: ^(NEHotspotHelperCommand * cmd) {
		if(cmd.commandType == kNEHotspotHelperCommandTypeFilterScanList) {
			for (NEHotspotNetwork* network  in cmd.networkList) {
				NSLog(@&quot;network.SSID = %@&quot;,network.SSID);
			}
		}
	}];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;kNEHotspotHelperCommandTypeFilterScanList： 表示扫描到 Wifi 列表信息。&lt;/p&gt;

&lt;p&gt;NEHotspotNetwork 里有如下信息：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;SSID：Wifi 名称&lt;/li&gt;
    &lt;li&gt;BSSID：站点的 MAC 地址&lt;/li&gt;
    &lt;li&gt;signalStrength： Wifi信号强度，该值在0.0-1.0之间&lt;/li&gt;
    &lt;li&gt;secure：网络是否安全 (不需要密码的 Wifi，该值为 false)&lt;/li&gt;
    &lt;li&gt;autoJoined： 设备是否自动连接该 Wifi，目前测试自动连接以前连过的 Wifi 的也为 false 。&lt;/li&gt;
    &lt;li&gt;justJoined：网络是否刚刚加入&lt;/li&gt;
    &lt;li&gt;chosenHelper：HotspotHelper是否为网络的所选助手&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/networkextension/nehotspotnetwork&quot;&gt;官方文档连接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;6获取wifi列表回调&quot;&gt;6、获取Wifi列表回调&lt;/h3&gt;

&lt;p&gt;当你把上面的代码写完，并成功运行项目后，发现并没有Wifi列表的回调。因为你还没刷新Wifi列表，你需要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打开手机系统设置 -&amp;gt; WLAN -&amp;gt; 系统 Wifi 列表加载出来时，上面代码部分才会回调，才能获取到 Wifi 列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/Wifilist/WLAN.png&quot; height=&quot;360&quot; width=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候你就能看到控制台源源不断的Log。&lt;/p&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1、获取Wifi列表功能由于是需要申请后台权限，所以能后台激活App(应用程序)，而且激活后App的进程能存活几个小时。&lt;/li&gt;
  &lt;li&gt;2、整个获取Wifi列表不需要App用户授权，也就是在App用户无感知下获取设备的Wifi列表信息，使用时请正当使用。&lt;/li&gt;
  &lt;li&gt;3、Wifi列表获取 NetworkExtension 是 iOS 9以后才出的，目前 iOS 9 已经覆盖很广了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面付一张来自 &lt;a href=&quot;https://www.talkingdata.com/index/#/device/os/zh_CN&quot;&gt;TalkingData 对iOS操作系统的统计报表&lt;/a&gt;，时间：2017-01-03&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/Wifilist/systemVersion.png&quot; height=&quot;280&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;p&gt;在操作过程或者文章有问题的话欢迎在 &lt;a href=&quot;http://baixin.io/2017/01/iOS_Wifilist/&quot;&gt;原文&lt;/a&gt; 里提问或指正。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用 Demo 我就不提供了，你如果没有申请 NetworkExtension 权限，提供了 Demo 你也无法使用。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;参考资源：&lt;a href=&quot;http://stackoverflow.com/questions/31704292/nehotspothelper-networkextension-api-ios9-0&quot;&gt;NEHotspotHelper NetworkExtension API iOS9.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2017/01/iOS_Wifilist/&quot;&gt;Wifi 定位原理及 iOS Wifi 列表获取&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/iOS_Wifilist/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/iOS_Wifilist/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS开发中的小问题记录</title>
        <description>&lt;h3 id=&quot;nskeyedarchiver-自定义对象写文件&quot;&gt;NSKeyedArchiver 自定义对象写文件&lt;/h3&gt;

&lt;p&gt;如果存储的对象类名有变动，则需要设置clasName, 方法为：“setClassName:forClass:”      &lt;br /&gt;
使用 NSKeyedArchiver 进行数据持久化时, 系统会默认使用类名去建表，如果类名变了，那么使用新的类名肯定是从本地获取不到表的，代码执行崩溃。   &lt;br /&gt;
所以需要在 NSKeyedArchiver 或者 NSKeyedUnarchiver 时使用 “setClassName:forClass:” 指定类名。&lt;/p&gt;

&lt;h3 id=&quot;断点配置generate-debug-symbols&quot;&gt;断点配置：【Generate Debug Symbols】&lt;/h3&gt;

&lt;p&gt;描述: 用来控制断点是否生效,关闭此功能，打包 &lt;code class=&quot;highlighter-rouge&quot;&gt;.ipa&lt;/code&gt; 时，包体积会小很多。  &lt;br /&gt;
配置路径:【project/TARGETS/Build Settings/Apple LLVM7.1 - Code Genneration/Generate Debug Symbols】&lt;/p&gt;

&lt;h3 id=&quot;捕获全局异常all-exception&quot;&gt;捕获全局异常：【All Exception】&lt;/h3&gt;

&lt;p&gt;描述: 用来捕捉整个项目在 Xcode 里执行时的异常。例如：try/catch 时 catch住的异常,【All Exception】可以直接定位到具体位置。   &lt;br /&gt;
配置路径: 异常捕捉(commod+7)/Xcode左下角点击+/Add Exception Breakpoint/完成(回车键)&lt;/p&gt;

&lt;h3 id=&quot;ui相关&quot;&gt;UI相关&lt;/h3&gt;

&lt;p&gt;1、设置状态栏颜色：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
info.plist 添加 View controller-based status bar appearance - NO     
代码里写 [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent]; 再次运行后状态栏就会变成白色。    

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、左滑返回手势失效了怎么办：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
设置 navigationItem.leftBarButtonItem 之后，左滑返回手势就会失效。设置一下 UIGestureRecognizerDelegate 代理即可：

self.navigationController.interactivePopGestureRecognizer.delegate = self;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、让 TableView的 下拉 和 上拉 显示不一样的背景颜色：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
给 TableView 上加一个 View，View 的 Frema：
CGRectMake(0, -self.view.bounds.size.height, self.view.bounds.size.width, self.view.bounds.size.height + 2)，
给变View的背景颜色就可以了。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2016/12/iOS_Dev_Note/&quot;&gt;iOS开发中的小问题记录&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/12/iOS_Dev_Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/12/iOS_Dev_Note/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS动态更新</title>
        <description>&lt;ul&gt;
  &lt;li&gt;1、控件到 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 的层级关系:&lt;/li&gt;
  &lt;li&gt;2、分析控件的详细路径:&lt;/li&gt;
  &lt;li&gt;3、动态修改控件:&lt;/li&gt;
  &lt;li&gt;4、工具篇:&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;视图的层级关系&quot;&gt;视图的层级关系&lt;/h3&gt;

&lt;p&gt;每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; , 至少有一个根 &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; , 通常情况下我们只用一个 。&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; , 这就是我们所谓的根视图 , 我们所有的控制器都是放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; 里面的。&lt;/p&gt;

&lt;p&gt;如果在项目里有了这么一个路径 , 我们可以做什么呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在当项目很复杂 , 可以其它地方可以直接修改这个控件的状态&lt;/li&gt;
  &lt;li&gt;当某个控件命名存在却又没有显示出来 , 可以通过路径来辅助查找&lt;/li&gt;
  &lt;li&gt;由服务器下发一些配置 , 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt; 去动态的修改已上线的项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面将介绍如何使用代码来找出这些视图(控件)的路径&lt;/p&gt;

&lt;h3 id=&quot;分析控件的详细路径&quot;&gt;分析控件的详细路径&lt;/h3&gt;

&lt;h4 id=&quot;1找出根-window-&quot;&gt;1、找出根 &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; :&lt;/h4&gt;

&lt;p&gt;每一个视图、控件 , 他们最终的根都是main函数返回的 &lt;code class=&quot;highlighter-rouge&quot;&gt;application&lt;/code&gt; , 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication]&lt;/code&gt; 可以得到 。 &lt;code class=&quot;highlighter-rouge&quot;&gt;application&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;windows&lt;/code&gt; 属性是一个数组 , 这里面装的是这个应用的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; , 我们通常用的是第一个也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;application.windows[0]&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2遍历视图-&quot;&gt;2、遍历视图 :&lt;/h4&gt;

&lt;p&gt;得到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 对象一切都好办了 。 然后拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; , 在获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; 里面所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;childViewControllers&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; 里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;subviews&lt;/code&gt; , 一直递归下去就可以得到当前屏幕里所有视图对象了 , 同时可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt; 把它们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt; 都获取出来。&lt;/p&gt;

&lt;p&gt;结合 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reveal&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Captuer View Hiearachy&lt;/code&gt; , 我们可以推测一下这两个的的实现原理了 :&lt;/p&gt;

&lt;p&gt;1、根据应用得到根视图  &lt;br /&gt;
2、递归获取里面的所有控件 &lt;br /&gt;
3、按照他们的层级关系一层一层的画出来&lt;/p&gt;

&lt;h3 id=&quot;动态修改控件&quot;&gt;动态修改控件&lt;/h3&gt;

&lt;p&gt;1、把上面获取到的所有控件的详细信息上传到服务器 。 &lt;br /&gt;
2、根据业务需求由服务器给我们下发对应的配置列表，以 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 为例 : 配置列表里必须要有 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1)、&lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的全路径 : 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UILayoutContainerView&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBar&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; —&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2)、&lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的唯一标识 : 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt; 值或自己实现的一套算法生成的唯一标识 , 目的是防止与 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 同一层次的视图搞混 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3)、 根据路径及唯一标识来匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; 里的控件 , 匹配和上面的查找原理是相通的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4)、 匹配成功代表  &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 确实存在 , 根据业务需求做后续操作 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;提示: 匹配策略尽可能的多 , 防止意外情况某一两个标识生成失败或者生成相同 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的状态。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1)、 如某个按钮点了会 &lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt; 或暂时不需要被点击 , 但是又要展示出来 , 可以直接修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;enabled&lt;/code&gt; 属性 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2)、 如某业务暂时关闭 , 可以直接修改入口 &lt;code class=&quot;highlighter-rouge&quot;&gt;按钮&lt;/code&gt; frame为0 , 前提是要自动布局已做好 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3)、 如给购买 &lt;code class=&quot;highlighter-rouge&quot;&gt;按钮&lt;/code&gt; 添加监听事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;addTarget: action: forControlEvents:&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; 也可以通过上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;遍历视图&lt;/code&gt; 获取到 , &lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt; 可以由服务器下发 , 也可以一开始就写死 , 等有需求的时候直接传不同的参数就行了 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、 绑定查找控件时 , 这个界面必须要已经初始化完成了才行 , 假如界面还没生成肯定是查找不到这个控件的 。 这里给大家提供两种思路 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、使用Runtime &lt;code class=&quot;highlighter-rouge&quot;&gt;Method Swizzing&lt;/code&gt; ,  直接把修改控件的方法与 &lt;code class=&quot;highlighter-rouge&quot;&gt;didMoveToSuperview&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;didMoveToWindow&lt;/code&gt; 动态绑定 , 等这个控件加载出来之后再去修改 , 查找路径正确的话肯定就能找到了 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、在具体的类里面 , 等控件的初始化方法调用完后 , 再去执行动态修改 , 如在&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 里面初始化控件 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewWillAppear:&lt;/code&gt; 里面动态修改 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议使用第一种适用范围更强 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上架后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;应用&lt;/code&gt; 可能会遇到的一些突发状况 , 未测出的&lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt;、临时改点小需求 , 等等 , 我们总不能每次因为一点小改动就重新提交一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;App Store&lt;/code&gt; , 先不说 &lt;code class=&quot;highlighter-rouge&quot;&gt;App Store&lt;/code&gt; 的审核时间 , 频繁的让用户去更新应用 , 用户也会烦的 。使用这篇文章所讲的来实现动态更新是再合适不过了 。&lt;/p&gt;

&lt;p&gt;首先上面讲的 &lt;code class=&quot;highlighter-rouge&quot;&gt;动态更新&lt;/code&gt; 是完全脱离出来的一个模块 , 跟业务逻辑没有任何关系 , 只需要部署一次就行了 , 等开发下一个项目也可以直接拿过去使用 。这里的动态更新适用于局部的视图、控件的修改 , 如果你有其它需求可以考虑 &lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;JSPatch&lt;/a&gt; , 下发脚本也是一个不错的选择 。&lt;/p&gt;

&lt;h3 id=&quot;工具篇&quot;&gt;工具篇&lt;/h3&gt;
&lt;p&gt;使用一些UI调试的辅助工具 , 使我们查看视图在项目中得层次结构更为方便 。      &lt;br /&gt;
常用的UI调试的工具：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Captuer View Hiearachy&lt;/li&gt;
  &lt;li&gt;Reveal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Xcode自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Captuer View Hiearachy&lt;/code&gt; 实现步骤:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、打开Xcode , 运行项目 , 选择最顶部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2、&lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View Debugging&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Show View Frames&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;3、&lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View Debugging&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Captuer View Hiearachy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Xcode里面就变成了三维的视图了 , Xcode左侧展示出来的是层级关系的树状图 。&lt;/p&gt;

&lt;p&gt;Reveal的功能相对来说更强大 , 适用于UI调试视图查找 。使用方法请看 &lt;a href=&quot;http://support.revealapp.com/kb/getting-started/reveal&quot;&gt;Reveal集成指南&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2016/01/iOS_OTA/&quot;&gt;点击阅读原文&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Jan 2016 19:15:06 +0800</pubDate>
        <link>http://localhost:4000/2016/01/iOS_OTA/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/01/iOS_OTA/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS 9 变化笔记</title>
        <description>&lt;p&gt;这里将介绍下我们日常开发一些从iOS8过度到iOS9给我们带来的一些变化，及解决方法。&lt;/p&gt;

&lt;h3 id=&quot;app-transport-security&quot;&gt;App Transport Security&lt;/h3&gt;

&lt;p&gt;iOS9和OS X El Capitan的一个新特性，App Transport Security 的目地是提高Apple 操作系统的安全性以及在此操作系统上运行的任何应用的安全性。ATS是苹果针对与 NSURL这一层做的封装，iOS9后ATS默认是开启的，即网络传输需要使用HTTPS。如果想在iOS9后继续使用HTTP的话，有两条路可以走：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;在Info.plist中添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSAppTransportSecurity&lt;/code&gt;类型Dictionary，在&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAppTransportSecurity&lt;/code&gt;下添加&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAllowsArbitraryLoads&lt;/code&gt;，Boolean 为 YES。&lt;/li&gt;
    &lt;li&gt;直接使用CFNetwork做网络请求，ASIHTTPRequest就是基于CFNetwotk做的封装，如果有需求的同学可以看看ASI里面的源码，如果某个时间段你又想要使用HTTPS的话，ASI对SSL/TSL的证书验证有点问题，证书验证还得自己封装一下才行。刚才我说道，ATS是苹果针对与NSURL这一层做的封装，所以我们使用CFNetwork或者更底层做网络请求的话是不受ATS限制的。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;移除了discoveryd-dns解析服务&quot;&gt;移除了discoveryd DNS解析服务&lt;/h3&gt;

&lt;p&gt;iPhone升级到iOS8后WiFi有时候会有问题，特别是Mac升级到OS X Yosemite后，时而电脑休眠唤醒唬就连不上WiFi，有时候还突然掉线，经常要手动去关闭WiFi在重新连接，这是因为苹果到了OS X Yosemite系统后，把之前的mDNSResponder换成了discoveryd DNS。iOS9和OS X Yosemite10.4后mDNSResponder又回来了。&lt;/p&gt;

&lt;p&gt;mDNSResponder： 苹果以前一直使用控制DNS和Bonjour服务的一种进程。
discoveryd：OS X Yosemite后苹果新出的一种进程。&lt;/p&gt;

&lt;h3 id=&quot;app-thinning&quot;&gt;App Thinning&lt;/h3&gt;
&lt;p&gt;App Thinning是一个关于节省iOS设备存储空间的功能，它可以让iOS设备在安装、更新及运行App等场景中仅下载所需的资源，减少App的占用空间，从而节省设备的存储空间。&lt;/p&gt;

&lt;h4 id=&quot;app-thinning主要有三个机制&quot;&gt;App Thinning主要有三个机制：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Slicing： 开发者把App安装包上传到AppStore后，Apple服务会自动对安装包切割为不同的应用变体(App variant)， 当用户下载安装包时，系统会根据设备型号下载安装对应的单个应用变体。&lt;/li&gt;
    &lt;li&gt;On-Demand Resources： ORD(随需资源)是指开发者对资源添加标签上传后，系统会根据App运行的情况，动态下载并加载所需资源，而在存储空间不足时，自动删除这类资源。&lt;/li&gt;
    &lt;li&gt;Bitcode：开启Bitcode编译后，可以使得开发者上传App时只需上传Intermediate Representation(中间件)，而非最终的可执行二进制文件。 在用户下载App之前，AppStore会自动编译中间件，产生设备所需的执行文件供用户下载安装。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，Bitcode的机制可以支持动态的进行App Slicing，而对于Apple未来进行硬件升级的措施，此机制可以保证在开发者不重新发布版本的情况下而兼容新的设备。Xcode7默认是开始了Bitcode，如果不想使用可以手动关闭Bitcode：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选择项目——&amp;gt;点击Target——&amp;gt;点击Build Setttings——&amp;gt;搜索栏里搜bitcode——&amp;gt;把Enable Bitcode对应的Yes改成No。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启用Bitcode编译机制，需要注意以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果应用开启Bitcode，那么其集成的其他第三方库也需要是Bitcode编译的包才能真正进行Bitcode编译&lt;/li&gt;
  &lt;li&gt;开启Bitcode编译后，编译产生的.app体积会变大(中间代码，不是用户下载的包)，且.dSYM文件不能用来崩溃日志的符号化（用户下载的包是Apple服务重新编译产生的，有产生新的符号文件），使用dSYM来收集Crash日志的同学得注意了。&lt;/li&gt;
  &lt;li&gt;通过Archive方式上传AppStore的包，可以在Xcode的Organizer工具中下载对应安装包的新的符号文件&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;后台定位&quot;&gt;后台定位&lt;/h3&gt;

&lt;p&gt;iOS9后苹果为了对保障用户的地理位置的隐私对App请求后台定位有了权限设置，则需要多加一些代码。如果不适配iOS9，就不能偷偷在后台定位，如果没有后台定位的权限也是可以在后台定位的，只是会出现蓝条。&lt;/p&gt;

&lt;p&gt;开启后台定位功能：&lt;code class=&quot;highlighter-rouge&quot;&gt;locationManager.allowsBackgroundLocationUpdates = YES;&lt;/code&gt;
locationManager是CLLocationManager的对象，用来管理整个定位的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置info.plist，添加一个Required background modes，Array类型的，然后在Required background modes里面Item 0对应的Value设置为App registers for location updates，这样就解决了iOS9后台定位出现蓝条的问题了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ui-testing&quot;&gt;UI Testing&lt;/h3&gt;
&lt;p&gt;Xcode7中苹果引入了一种新的方式在应用中进行测试——UI Testting，UI Testting允许我们找到UI元素与之交互，还能检查属性和状态。UI Testting已经完全集成进了Xcode7的测试报告，可以和单元测试一起执行。使用起来跟之前Xcode5出来的XCTest差不多，Xcode bots提供对此的支持，而且command line支持当UI测试失败时会立即发出通知。&lt;/p&gt;

&lt;p&gt;可以参考Github上的Demo，步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在DemoTests.m里创建一个test开头的方法&lt;/li&gt;
  &lt;li&gt;在setUp()里启动应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;XCUIApplication().launch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;新建一个方法test开头的，在里面获取应用&lt;code class=&quot;highlighter-rouge&quot;&gt;let app = XCUIApplication()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;的到&lt;code class=&quot;highlighter-rouge&quot;&gt;let app = XCUIApplication()&lt;/code&gt;，a&lt;code class=&quot;highlighter-rouge&quot;&gt;pp.buttons[“View Detail”].tap()?&lt;/code&gt;。buttons是当前这个界面的所有按钮的集合，[]里面写按钮的名字，tap()就是执行这个按钮所对应的方法，可以是网络请求、界面跳转等等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;url-scheme&quot;&gt;URL scheme&lt;/h3&gt;

&lt;p&gt;在iOS9中，如果使用URL scheme必须在”Info.plist”中将你要在外部调用的URL scheme列为白名单，否则不能使用。&lt;/p&gt;

&lt;p&gt;配置info.plist，添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;LSApplicationQueriesSchemes&lt;/code&gt;，Array类型的，然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;LSApplicationQueriesSchemes&lt;/code&gt;的Item里面添加urlscheme就行了，urlscheme是任意一个字符串，就是你自己需要使用的urlscheme，iOS9 URL scheme白名单适配就完成了。&lt;/p&gt;

&lt;h3 id=&quot;出现大量的警告&quot;&gt;出现大量的警告&lt;/h3&gt;

&lt;p&gt;Xcode7后运行以前的项目后出现大量的警告如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;null&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: warning: /var/folders/p4/z7zy68r92hd3p5ry5g2v3k_8rlwzzr/C/org.llvm.clang.dalmo/ModuleCache/1TXZDLI9N2EMV/Foundation-3DFYNEBRQSXST.pcm: No such file or directory。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作为一个有洁癖的我反正是不能忍，出现警告的大致原因跟我上面提到的开启Bitcode，.dSYM文件不能用来符号化有关，Xcode试图去创建dSYM文件，但是你又不需要。&lt;/p&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Build Settings ——&amp;gt;Build Options——&amp;gt;Debug Information Format&lt;/li&gt;
  &lt;li&gt;Debug下的DWARF with dsYM File改成DWARF&lt;/li&gt;
  &lt;li&gt;Release下的还是之前默认的DWARF with dsYM File不变&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ChenYilong/iOS9AdaptationTips&quot;&gt;iOS9AdaptationTips&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150821/13140.html&quot;&gt;iOS9学习系列&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shinobicontrols/iOS9-day-by-day&quot;&gt;iOS9-day-by-day&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2015/09/iOS9_Note/&quot;&gt;点击阅读原文&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Sep 2015 02:15:06 +0800</pubDate>
        <link>http://localhost:4000/2015/09/iOS9_Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/09/iOS9_Note/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>HEXO搭建个人博客</title>
        <description>&lt;p&gt;　　经过各种找资料，踩过各种坑，终于使用 hexo 搭建个人博客初步完成了，域名目前用得时 github 的，我的 hexo 是 3.1.1 版本，hexo 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。&lt;/p&gt;

&lt;p&gt;　　本篇文章累计了大量评论，和我的一些解答，读者有什么问题可以先看看评论，或者搜下关键字，如果还是有问题可以给我在评论里给我留言，问题很着急的可以加我 ＱＱ：1499065178　，或者给我发邮件：&lt;a href=&quot;mailto:leopardpan@icloud.com&quot;&gt;leopardpan@icloud.com&lt;/a&gt;  ，都可以，如果你已经搭建完成了，可以看看我的另一篇博客&lt;a href=&quot;http://baixin.io/2016/06/HEXO_Advanced/&quot;&gt;HEXO进阶&lt;/a&gt;，有讲如何能百度搜索你的博客、多台电脑使用HEXO发布博客等。我现在的博客是使用 Jekyll 搭建的，如果你想使用我现在的模板请看&lt;a href=&quot;http://baixin.io/2016/10/jekyll_tutorials1/&quot;&gt;Jekyll搭建个人博客&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;
&lt;p&gt;　这边教程是针对与Mac的，&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&quot;&gt;参考链接&lt;/a&gt;，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。&lt;/p&gt;

&lt;p&gt;　之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客（在我的友情链接里有），貌似都是用hexo写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。&lt;/p&gt;

&lt;h2 id=&quot;配置环境&quot;&gt;配置环境&lt;/h2&gt;

&lt;h3 id=&quot;安装node必须&quot;&gt;安装Node（必须）&lt;/h3&gt;

&lt;p&gt;作用：用来生成静态页面的
到Node.js&lt;a href=&quot;https://nodejs.org/&quot;&gt;官网&lt;/a&gt;下载相应平台的最新版本，一路安装即可。&lt;/p&gt;

&lt;h3 id=&quot;安装git必须&quot;&gt;安装Git（必须）&lt;/h3&gt;
&lt;p&gt;作用：把本地的hexo内容提交到github上去.
安装Xcode就自带有Git，我就不多说了。&lt;/p&gt;

&lt;h3 id=&quot;申请github必须&quot;&gt;申请GitHub（必须）&lt;/h3&gt;
&lt;p&gt;作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。
&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。&lt;/p&gt;

&lt;h3 id=&quot;正式安装hexo&quot;&gt;正式安装HEXO　&lt;/h3&gt;
&lt;p&gt;Node和Git都安装好后，可执行如下命令安装hexo：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;p&gt;创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好啦，至此，全部安装工作已经完成！&lt;/p&gt;

&lt;h3 id=&quot;生成静态页面&quot;&gt;生成静态页面&lt;/h3&gt;
&lt;p&gt;继续再Blog目录下执行如下命令，生成静态页面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo generate （hexo g  也可以）   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;本地启动&quot;&gt;本地启动&lt;/h3&gt;
&lt;p&gt;启动本地服务，进行文章预览调试，命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo server   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;浏览器输入&lt;a href=&quot;就可以看到最原始的效果了&quot;&gt;http://localhost:4000&lt;/a&gt;
我不知道你们能不能，反正我不能，因为我还有环境没配置好&lt;/p&gt;

&lt;h3 id=&quot;常见的hexo配置错误&quot;&gt;常见的HEXO配置错误：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR Plugin load failed: hexo-server

原因： Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.

解决方法，执行命令：$ sudo npm install hexo-server

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;执行命令hexo server，提示：Usage: hexo&amp;lt;Command&amp;gt; ....

原因：我认为是没有生成本地服务

解决方法，执行命令：$ npm install hexo-server --save

提示：hexo-server@0.1.2 node_modules/hexo-server
.... 

表示成功了[参考](https://hexo.io/zh-cn/docs/server.html)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候再执行：$ hexo-server&lt;/p&gt;

&lt;p&gt;得到: INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.&lt;/p&gt;

&lt;p&gt;这个时候再点击&lt;a href=&quot;http://0.0.0.0:4000&quot;&gt;http://0.0.0.0:4000&lt;/a&gt;，正常情况下应该是最原始的画面，但是我看到的是：
白板和Cannot GET /   几个字
原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install hexo-renderer-ejs --save
npm install hexo-renderer-stylus --save
npm install hexo-renderer-marked --save
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候再重新生成静态文件，命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo generate （或hexo g）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动本地服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo server （或hexo s）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再点击网址&lt;a href=&quot;http://0.0.0.0:4000&quot;&gt;http://0.0.0.0:4000&lt;/a&gt; OK终于可以看到属于你自己的blog啦，?，虽然很简陋，但好歹有了一个属于自己的小窝了。&lt;a href=&quot;https://disqus.com/home/discussion/bsspirit/hexogithubweb/&quot;&gt;参考链接&lt;/a&gt;，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。&lt;/p&gt;

&lt;h2 id=&quot;配置github&quot;&gt;配置Github&lt;/h2&gt;

&lt;h3 id=&quot;建立repository&quot;&gt;建立Repository&lt;/h3&gt;

&lt;p&gt;建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法
然后建立关联，我的Blog在本地/Users/leopard/Blog，Blog是我之前建的东西也全在这里面，有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blog      &lt;br /&gt;
　｜      &lt;br /&gt;
　｜－－ _config.yml     &lt;br /&gt;
　｜－－ node_modules    &lt;br /&gt;
　｜－－ public              &lt;br /&gt;
　｜－－ source                                                &lt;br /&gt;
　｜－－ db.json	        &lt;br /&gt;
　｜－－ package.json        &lt;br /&gt;
　｜－－ scaffolds        &lt;br /&gt;
　｜－－ themes          　　　　　
　　　&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在我们需要_config.yml文件，来建立关联，命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim _config.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;翻到最下面，改成我这样子的，注意： &lt;code class=&quot;highlighter-rouge&quot;&gt;: 后面要有空格&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/leopardpan/leopardpan.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行如下命令才能使用git部署&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网上会有很多说法，有的type是github, 还有repository 最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。
忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。
然后，执行配置命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　然后再浏览器中输入&lt;a href=&quot;http://leopardpan.github.io/&quot;&gt;http://leopardpan.github.io/&lt;/a&gt;就行了，我的 github 的账户叫 leopardpan ,把这个改成你 github 的账户名就行了&lt;/p&gt;

&lt;h3 id=&quot;部署步骤&quot;&gt;部署步骤&lt;/h3&gt;

&lt;p&gt;每次部署的步骤，可按以下三步来进行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo clean
hexo generate
hexo deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一些常用命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  #查看帮助
hexo version  #查看Hexo的版本
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有大量的&lt;a href=&quot;https://github.com/hexojs/hexo/wiki/Themes&quot;&gt;主题列表&lt;/a&gt;使用方法里面
都有详细的介绍，我就不多说了。    &lt;br /&gt;
我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，?       &lt;br /&gt;
　&lt;a href=&quot;https://github.com/daisygao/hexo-themes-cover&quot;&gt;Cover&lt;/a&gt; - A chic theme with facebook-like cover photo    &lt;br /&gt;
　&lt;a href=&quot;https://github.com/henryhuang/oishi&quot;&gt;Oishi&lt;/a&gt; - A white theme based on Landscape plus and Writing.    &lt;br /&gt;
　&lt;a href=&quot;https://github.com/hardywu/hexo-theme-sidebar&quot;&gt;Sidebar&lt;/a&gt; - Another theme based on Light with a simple sidebar  &lt;br /&gt;
　&lt;a href=&quot;https://github.com/SuperKieran/TKL&quot;&gt;TKL&lt;/a&gt; - A responsive design theme for Hexo. 一个设计优雅的响应式主题  &lt;br /&gt;
　&lt;a href=&quot;https://github.com/levonlin/Tinnypp&quot;&gt;Tinnypp&lt;/a&gt; - A clean, simple theme based on Tinny   &lt;br /&gt;
　&lt;a href=&quot;https://github.com/yunlzheng/hexo-themes-writing&quot;&gt;Writing&lt;/a&gt; - A small and simple hexo theme based on Light   &lt;br /&gt;
　&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot;&gt;Yilia&lt;/a&gt; - Responsive and simple style 优雅简洁响应式主题，我用得就是这个。  &lt;br /&gt;
　&lt;a href=&quot;https://github.com/Voidly/pacman&quot;&gt;Pacman voidy&lt;/a&gt; - A theme with dynamic tagcloud and dynamic snow&lt;/p&gt;

&lt;h3 id=&quot;一些基本路径&quot;&gt;一些基本路径&lt;/h3&gt;
&lt;p&gt;　文章在 source/_posts，编辑器可以用 Sublime，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public/index.html 里修改，开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。&lt;/p&gt;

&lt;p&gt;Markdown语法参考链接: &lt;a href=&quot;https://www.zybuluo.com/mdeditor&quot;&gt;作业部落&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;问：如何让文章想只显示一部分和一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;阅读全文&lt;/code&gt; 的按钮？     &lt;br /&gt;
答：在文章中加一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; ， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 后面的内容就不会显示出来了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，&lt;code class=&quot;highlighter-rouge&quot;&gt;出现 404 &lt;/code&gt; .    &lt;br /&gt;
答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;转载请注明原地址，潘柏信的博客：&lt;a href=&quot;http://leopardpan.github.io&quot;&gt;http://leopardpan.github.io&lt;/a&gt; 谢谢！&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>博客</category>
        
        
      </item>
    
  </channel>
</rss>
